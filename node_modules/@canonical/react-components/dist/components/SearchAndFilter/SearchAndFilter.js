"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _FilterPanelSection = _interopRequireDefault(require("./FilterPanelSection"));

var _Chip = _interopRequireDefault(require("../Chip"));

var _utils = require("./utils");

var _hooks = require("../../hooks");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var SearchAndFilter = function SearchAndFilter(_ref) {
  var _ref$existingSearchDa = _ref.existingSearchData,
      existingSearchData = _ref$existingSearchDa === void 0 ? [] : _ref$existingSearchDa,
      filterPanelData = _ref.filterPanelData,
      returnSearchData = _ref.returnSearchData;

  var _useState = (0, _react.useState)(existingSearchData),
      _useState2 = _slicedToArray(_useState, 2),
      searchData = _useState2[0],
      setSearchData = _useState2[1];

  var _useState3 = (0, _react.useState)(""),
      _useState4 = _slicedToArray(_useState3, 2),
      searchTerm = _useState4[0],
      setSearchTerm = _useState4[1];

  var _useState5 = (0, _react.useState)(true),
      _useState6 = _slicedToArray(_useState5, 2),
      filterPanelHidden = _useState6[0],
      setFilterPanelHidden = _useState6[1];

  var _useState7 = (0, _react.useState)(false),
      _useState8 = _slicedToArray(_useState7, 2),
      searchBoxExpanded = _useState8[0],
      setSearchBoxExpanded = _useState8[1];

  var _useState9 = (0, _react.useState)(0),
      _useState10 = _slicedToArray(_useState9, 2),
      overflowSearchTermCounter = _useState10[0],
      setOverflowSearchTermCounter = _useState10[1];

  var _useState11 = (0, _react.useState)(false),
      _useState12 = _slicedToArray(_useState11, 2),
      searchContainerActive = _useState12[0],
      setSearchContainerActive = _useState12[1];

  var searchAndFilterRef = (0, _react.useRef)(null);
  var searchContainerRef = (0, _react.useRef)(null);
  var searchBoxRef = (0, _react.useRef)(null); // Return searchData to parent component

  (0, _react.useEffect)(function () {
    var mounted = true;
    returnSearchData && mounted && returnSearchData(searchData);
    return function () {
      mounted = false;
    };
  }, [searchData, returnSearchData]);

  var searchOnChange = function searchOnChange(searchTerm) {
    setSearchTerm(searchTerm);
  }; // Hide manual input form field when search container is inactive


  (0, _react.useEffect)(function () {
    var searchContainerClickCheck = function searchContainerClickCheck(e) {
      var _e$target;

      var clickInContainer = ((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.closest(".p-search-and-filter")) !== null;
      setSearchContainerActive(clickInContainer);
    };

    document.addEventListener("click", searchContainerClickCheck);
    return function () {
      document.removeEventListener("click", searchContainerClickCheck);
    };
  }, [searchContainerActive]);

  var closePanel = function closePanel() {
    setFilterPanelHidden(true);
  };

  (0, _hooks.useOnEscapePressed)(function () {
    return closePanel();
  }); // This useEffect sets up listeners so the panel will close if user clicks
  // anywhere else on the page or hits the escape key

  (0, _react.useEffect)(function () {
    var mouseDown = function mouseDown(e) {
      var _searchAndFilterRef$c;

      // Check if click is outside of filter panel
      if (!(searchAndFilterRef !== null && searchAndFilterRef !== void 0 && (_searchAndFilterRef$c = searchAndFilterRef.current) !== null && _searchAndFilterRef$c !== void 0 && _searchAndFilterRef$c.contains(e.target))) {
        // If so, close the panel
        closePanel();
      }
    }; // Add listener on document to capture click events


    document.addEventListener("mousedown", mouseDown); // return function to be called when unmounted

    return function () {
      document.removeEventListener("mousedown", mouseDown);
    };
  }, []); // Add passed chip to the searchData array

  var toggleSelected = function toggleSelected(chip) {
    var currentSelected = _toConsumableArray(searchData);

    if (!(0, _utils.isChipInArray)(chip, currentSelected)) {
      currentSelected.push(chip);
      setSearchData(currentSelected);
      setSearchTerm("");
    } else {
      var updatedCurrentSelected = currentSelected.filter(function (currentSelectedChip) {
        return currentSelectedChip.value !== chip.value;
      });
      setSearchData(updatedCurrentSelected);
    }
  }; // Remove passed chip from the searchData array


  var removeFromSelected = function removeFromSelected(chip) {
    if (searchData.includes(chip)) {
      var updatedSelected = searchData.filter(function (searchDataChip) {
        return searchDataChip !== chip;
      });
      setSearchData(updatedSelected);
    }
  }; // When overflow chips are shown, clicking anywhere outside search area
  // or clicking on a chip should hide them again


  (0, _react.useEffect)(function () {
    var hideOverflowChips = function hideOverflowChips(e) {
      if (!e.target.closest(".p-search-and-filter") && e.target.className !== "p-icon--close") {
        setSearchBoxExpanded(false);
      }
    };

    document.addEventListener("click", function (e) {
      hideOverflowChips(e);
    });
    return function () {
      document.removeEventListener("click", function (e) {
        hideOverflowChips(e);
      });
    };
  }, []);

  var handleSubmit = function handleSubmit() {
    if (searchTerm.trim() !== "") {
      toggleSelected({
        value: searchTerm,
        quoteValue: true
      });
      setSearchTerm("");
    }
  }; // If the offsetTop is more than double height of a single chip, consider it
  // overflowing


  var updateFlowCount = function updateFlowCount() {
    var _searchContainerRef$c;

    var chips = searchContainerRef === null || searchContainerRef === void 0 ? void 0 : (_searchContainerRef$c = searchContainerRef.current) === null || _searchContainerRef$c === void 0 ? void 0 : _searchContainerRef$c.querySelectorAll(".p-chip");
    var overflowCount = (0, _utils.overflowingChipsCount)(chips, 1);
    setOverflowSearchTermCounter(overflowCount);
  }; // Watch for container resize and recalculate overflow count accordingly


  (0, _react.useEffect)(function () {
    var resizeObserverSupported = typeof ResizeObserver !== "undefined";
    var wrapper = searchContainerRef.current;
    var wrapperWidthObserver;

    if (resizeObserverSupported && wrapper) {
      wrapperWidthObserver = new ResizeObserver(function () {
        updateFlowCount();
      });
      wrapperWidthObserver.observe(wrapper);
    } else {
      updateFlowCount();
    }

    return function () {
      var _wrapperWidthObserver;

      resizeObserverSupported && ((_wrapperWidthObserver = wrapperWidthObserver) === null || _wrapperWidthObserver === void 0 ? void 0 : _wrapperWidthObserver.disconnect());
    };
  }, [searchData]); // Add search prompt value to search on Enter key

  var searchPromptKeyDown = function searchPromptKeyDown(e) {
    if (e.key === "Enter") {
      handleSubmit();
    }
  };

  var searchBox = searchBoxRef.current;
  var searchContainer = searchContainerRef.current;

  if (!searchBoxExpanded && searchBox && searchContainer && overflowSearchTermCounter === 0) {
    if (searchBox.offsetTop > searchContainer.offsetHeight) {
      setSearchBoxExpanded(true);
    }
  } // If chips or input field contains values, clear 'em out


  var clearAllSearchTerms = function clearAllSearchTerms() {
    setSearchTerm("");
  };

  var placeholder = searchData.length ? "Add filter" : "Search and filter";
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "p-search-and-filter",
    ref: searchAndFilterRef,
    onClick: function onClick() {
      return filterPanelHidden && setFilterPanelHidden(false);
    }
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "p-search-and-filter__search-container",
    "aria-expanded": searchBoxExpanded,
    "data-active": searchContainerActive || searchData.length === 0,
    "data-empty": searchData.length <= 0,
    ref: searchContainerRef
  }, searchTerm !== "" && /*#__PURE__*/_react.default.createElement("button", {
    className: "p-search-and-filter__clear",
    onClick: function onClick() {
      return clearAllSearchTerms();
    }
  }, /*#__PURE__*/_react.default.createElement("i", {
    className: "p-icon--close"
  })), Object.values(searchData).map(function (chip) {
    return /*#__PURE__*/_react.default.createElement(_Chip.default, {
      lead: chip.lead,
      value: chip.value,
      key: "search-".concat(chip.lead, "+").concat(chip.value),
      onDismiss: function onDismiss() {
        return removeFromSelected(chip);
      },
      selected: true,
      quoteValue: chip.quoteValue
    });
  }), /*#__PURE__*/_react.default.createElement("form", {
    className: "p-search-and-filter__box",
    onSubmit: function onSubmit(e) {
      e.preventDefault();
      handleSubmit();
    },
    "data-overflowing": searchBoxExpanded,
    ref: searchBoxRef
  }, /*#__PURE__*/_react.default.createElement("label", {
    className: "u-off-screen",
    htmlFor: "search-and-filter-input"
  }, searchData.length ? "Add filter" : "Search and filter"), /*#__PURE__*/_react.default.createElement("input", {
    autoComplete: "off",
    className: "p-search-and-filter__input",
    id: "search-and-filter-input",
    name: "search",
    onChange: function onChange(e) {
      return searchOnChange(e.target.value);
    },
    placeholder: placeholder,
    type: "search",
    value: searchTerm
  }), /*#__PURE__*/_react.default.createElement("button", {
    className: "u-off-screen",
    type: "submit"
  }, "Search")), overflowSearchTermCounter > 0 && /*#__PURE__*/_react.default.createElement("span", {
    className: "p-search-and-filter__selected-count",
    onClick: function onClick() {
      return setSearchBoxExpanded(true);
    },
    onKeyDown: function onKeyDown() {
      return setSearchBoxExpanded(true);
    },
    role: "button",
    tabIndex: 0
  }, "+", overflowSearchTermCounter)), (filterPanelData.length > 0 || searchTerm.length > 0) && /*#__PURE__*/_react.default.createElement("div", {
    className: "p-search-and-filter__panel",
    "aria-hidden": filterPanelHidden
  }, /*#__PURE__*/_react.default.createElement("div", null, searchTerm.length > 0 && /*#__PURE__*/_react.default.createElement("div", {
    className: "p-search-and-filter__search-prompt",
    onClick: function onClick() {
      return handleSubmit();
    },
    onKeyDown: function onKeyDown(e) {
      return searchPromptKeyDown(e);
    },
    role: "button",
    tabIndex: 0
  }, "Search for", " ", /*#__PURE__*/_react.default.createElement("span", {
    className: "p-search-and-filter__search-query"
  }, searchTerm), "..."), filterPanelData.map(function (filterPanelSectionData) {
    return /*#__PURE__*/_react.default.createElement(_FilterPanelSection.default, {
      key: filterPanelSectionData.id,
      data: filterPanelSectionData,
      toggleSelected: toggleSelected,
      searchData: searchData,
      searchTerm: searchTerm
    });
  }))));
};

SearchAndFilter.propTypes = {
  existingSearchData: _propTypes.default.array,
  filterPanelData: _propTypes.default.array.isRequired,
  returnSearchData: _propTypes.default.func.isRequired
};
var _default = SearchAndFilter;
exports.default = _default;