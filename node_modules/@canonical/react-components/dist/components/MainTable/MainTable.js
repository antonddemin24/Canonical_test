"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _Pagination = _interopRequireDefault(require("../Pagination"));

var _Table = _interopRequireDefault(require("../Table"));

var _TableRow = _interopRequireDefault(require("../TableRow"));

var _TableHeader = _interopRequireDefault(require("../TableHeader"));

var _TableCell = _interopRequireDefault(require("../TableCell"));

var _hooks = require("../../hooks");

var _excluded = ["content", "sortKey"],
    _excluded2 = ["columns", "expanded", "expandedContent", "key", "sortData"],
    _excluded3 = ["content"],
    _excluded4 = ["defaultSort", "defaultSortDirection", "emptyStateMsg", "expanding", "headers", "onUpdateSort", "paginate", "rows", "responsive", "sortable", "sortFunction"];

var _this = void 0;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var updateSort = function updateSort(setSortKey, setSortDirection, sortKey, sortDirection) {
  var newDirection = null;

  if (sortDirection === "none") {
    newDirection = "ascending";
  } else if (sortDirection === "ascending") {
    newDirection = "descending";
  } else {
    sortKey = null;
  }

  setSortKey(sortKey);
  setSortDirection(newDirection);
};

var generateHeaders = function generateHeaders(currentSortKey, currentSortDirection, expanding, headers, sortable, setSortKey, setSortDirection) {
  var headerItems = headers.map(function (_ref, index) {
    var content = _ref.content,
        sortKey = _ref.sortKey,
        props = _objectWithoutProperties(_ref, _excluded);

    var sortDirection;

    if (sortable && sortKey) {
      if (currentSortKey === sortKey) {
        sortDirection = currentSortDirection;
      } else {
        sortDirection = "none";
      }
    }

    return /*#__PURE__*/_react.default.createElement(_TableHeader.default, _extends({
      key: index,
      sort: sortDirection,
      onClick: sortable ? updateSort.bind(_this, setSortKey, setSortDirection, sortKey, sortDirection) : undefined
    }, props), content);
  }); // When there is expanding content then provide an extra hidden header to
  // account for the extra cell in the body rows.

  return /*#__PURE__*/_react.default.createElement("thead", null, /*#__PURE__*/_react.default.createElement(_TableRow.default, null, headerItems, expanding && /*#__PURE__*/_react.default.createElement(_TableHeader.default, {
    "aria-hidden": "true"
  })));
};

var generateRows = function generateRows(_ref2) {
  var rows = _ref2.rows,
      headers = _ref2.headers,
      responsive = _ref2.responsive,
      expanding = _ref2.expanding;
  return rows.map(function (_ref3, index) {
    var columns = _ref3.columns,
        expanded = _ref3.expanded,
        expandedContent = _ref3.expandedContent,
        key = _ref3.key,
        sortData = _ref3.sortData,
        rowProps = _objectWithoutProperties(_ref3, _excluded2);

    var cellItems = columns === null || columns === void 0 ? void 0 : columns.map(function (_ref4, index) {
      var content = _ref4.content,
          cellProps = _objectWithoutProperties(_ref4, _excluded3);

      var headerContent = headers && headers[index]["content"];
      var headerReplacement = headers && headers[index]["heading"];

      if (responsive) {
        cellProps["data-heading"] = typeof headerContent === "string" ? headerContent : headerReplacement;
      }

      return /*#__PURE__*/_react.default.createElement(_TableCell.default, _extends({
        key: index
      }, cellProps), content);
    }); // if key was not provided as a prop, use row's index instead

    if (key === null || typeof key === "undefined") {
      key = index;
    } // The expanding cell is alway created to match the correct number of
    // table cells in rows that do have expanding content.


    return /*#__PURE__*/_react.default.createElement(_TableRow.default, _extends({
      key: key
    }, rowProps), cellItems, expanding && /*#__PURE__*/_react.default.createElement(_TableCell.default, {
      expanding: true,
      hidden: !expanded
    }, expandedContent));
  });
};

var sortRows = function sortRows(_ref5) {
  var currentSortDirection = _ref5.currentSortDirection,
      currentSortKey = _ref5.currentSortKey,
      rows = _ref5.rows,
      sortable = _ref5.sortable,
      sortFunction = _ref5.sortFunction;

  if (!rows) {
    return [];
  } // Clone the rows so we can restore the original order.


  var sortedRows = _toConsumableArray(rows);

  if (sortable && currentSortKey) {
    if (!sortFunction) {
      sortFunction = function sortFunction(a, b) {
        if (!a.sortData || !b.sortData) {
          return 0;
        }

        if (a.sortData[currentSortKey] > b.sortData[currentSortKey]) {
          return currentSortDirection === "ascending" ? 1 : -1;
        } else if (a.sortData[currentSortKey] < b.sortData[currentSortKey]) {
          return currentSortDirection === "ascending" ? -1 : 1;
        }

        return 0;
      };
    }

    sortedRows.sort(function (a, b) {
      return sortFunction(a, b, currentSortDirection, currentSortKey);
    });
  }

  return sortedRows;
};

var MainTable = function MainTable(_ref6) {
  var defaultSort = _ref6.defaultSort,
      defaultSortDirection = _ref6.defaultSortDirection,
      _ref6$emptyStateMsg = _ref6.emptyStateMsg,
      emptyStateMsg = _ref6$emptyStateMsg === void 0 ? "" : _ref6$emptyStateMsg,
      expanding = _ref6.expanding,
      headers = _ref6.headers,
      onUpdateSort = _ref6.onUpdateSort,
      paginate = _ref6.paginate,
      rows = _ref6.rows,
      responsive = _ref6.responsive,
      sortable = _ref6.sortable,
      sortFunction = _ref6.sortFunction,
      props = _objectWithoutProperties(_ref6, _excluded4);

  var _useState = (0, _react.useState)(defaultSort),
      _useState2 = _slicedToArray(_useState, 2),
      currentSortKey = _useState2[0],
      setSortKey = _useState2[1];

  var _useState3 = (0, _react.useState)(defaultSortDirection),
      _useState4 = _slicedToArray(_useState3, 2),
      currentSortDirection = _useState4[0],
      setSortDirection = _useState4[1]; // Update the current sort state if the prop changes.


  (0, _react.useEffect)(function () {
    setSortKey(defaultSort);
  }, [defaultSort]); // Update the current sort direction state if the prop changes.

  (0, _react.useEffect)(function () {
    setSortDirection(defaultSortDirection);
  }, [defaultSortDirection]);

  var updateSort = function updateSort(newSort) {
    setSortKey(newSort);
    onUpdateSort && onUpdateSort(newSort);
  };

  var sortedRows = (0, _react.useMemo)(function () {
    return sortRows({
      currentSortDirection: currentSortDirection,
      currentSortKey: currentSortKey,
      rows: rows,
      sortable: sortable,
      sortFunction: sortFunction
    });
  }, [currentSortDirection, currentSortKey, rows, sortable, sortFunction]);

  var _usePagination = (0, _hooks.usePagination)(sortedRows, {
    itemsPerPage: paginate,
    autoResetPage: true
  }),
      finalRows = _usePagination.pageData,
      currentPage = _usePagination.currentPage,
      setCurrentPage = _usePagination.paginate;

  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_Table.default, _extends({
    expanding: expanding,
    responsive: responsive
  }, props), !!headers && generateHeaders(currentSortKey, currentSortDirection, expanding, headers, sortable, updateSort, setSortDirection), // If the table has no rows, return empty state message
  Object.entries(finalRows).length === 0 && emptyStateMsg ? /*#__PURE__*/_react.default.createElement("caption", null, emptyStateMsg) : /*#__PURE__*/_react.default.createElement("tbody", null, generateRows({
    rows: finalRows,
    headers: headers,
    responsive: responsive,
    expanding: expanding
  }))), paginate && rows && rows.length > 0 && /*#__PURE__*/_react.default.createElement(_Pagination.default, {
    currentPage: currentPage,
    itemsPerPage: paginate,
    paginate: setCurrentPage,
    style: {
      marginTop: "1rem"
    },
    totalItems: rows.length
  }));
};

var _default = MainTable;
exports.default = _default;